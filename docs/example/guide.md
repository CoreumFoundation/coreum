# Using `pkg/client`

This document give instructions and examples on how to use our `pkg/client` package to broadcast transactions and query the Coreum blockchain using go programming language.

## Skeleton

Create standard `main.go` file containing this skeleton importing `pkg/client`:

```go
package main

import (
	"github.com/CoreumFoundation/coreum/pkg/client"
	"github.com/CoreumFoundation/coreum/pkg/config/constant"
)

func main() {
	const (
		walletMnemonic = "" // put mnemonic here

		addressPrefix    = "devcore"
		chainID          = "coreum-devnet-1"
		recipientAddress = "devcore1ckuncyw0hftdq5qfjs6ee2v6z73sq0urd390cd"
		nodeAddress      = "https://s-0.devnet-1.coreum.dev:443"
	)
}
```

## Preparing test account

Before you may broadcast transactions, you need to have access to funded account.
Normally you would create a private key stored securely in local keystore.
Here, for simplicity, we will use private key generated by our faucet. Keep in mind, to not use key generated that way in production!

To get funded account, go to our faucet website: https://docs.coreum.dev/tools-ecosystem/faucet
and click on "Generate Funded Wallet" button.

In response, you get your wallet address on our devnet chain and mnemonic used to generate the private key.
Assign mnemonic to the constant `walletMnemonic` in the code snippet above.

## Setting Cosmos SDK configuration

First we need to configure Cosmos SDK:

```go
	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(addressPrefix, addressPrefix+"pub")
	config.SetCoinType(constant.CoinType)
	config.Seal()
```

## Preparing client context and tx factory

Before we are able to broadcast transaction, we must create and configure client context and tx factory:

```go
	modules := module.NewBasicManager(
		auth.AppModuleBasic{},
		bank.AppModuleBasic{},
	)

	rpcClient, err := cosmosclient.NewClientFromNode(nodeAddress)
	if err != nil {
		panic(err)
	}

	clientCtx := client.NewContext(client.DefaultContextConfig(), modules).
		WithChainID(chainID).
		WithClient(rpcClient).
		WithKeyring(keyring.NewInMemory()).
		WithBroadcastMode(flags.BroadcastBlock)

	txFactory := client.Factory{}.
		WithKeybase(clientCtx.Keyring()).
		WithChainID(clientCtx.ChainID()).
		WithTxConfig(clientCtx.TxConfig()).
		WithSimulateAndExecute(true)
```
## Generate private key

To sign a transaction, private key generated from mnemonic stored in `walletMnemonic` is required. We store that key in the temporary keystore:

```go
	senderInfo, err := clientCtx.Keyring().NewAccount(
		"key-name",
		walletMnemonic,
		"",
		sdk.GetConfig().GetFullBIP44Path(),
		hd.Secp256k1,
	)
	if err != nil {
		panic(err)
	}
```

## Broadcasting transaction

Now we are ready to broadcast transaction. As an example we send `10ducore` tokens from your wallet to `recipientAddress`:

```go
	msg := &banktypes.MsgSend{
		FromAddress: senderInfo.GetAddress().String(),
		ToAddress:   recipientAddress,
		Amount:      sdk.NewCoins(sdk.NewInt64Coin("ducore", 10)),
	}

	ctx := context.Background()
	result, err := client.BroadcastTx(
		ctx,
		clientCtx.WithFromAddress(senderInfo.GetAddress()),
		txFactory,
		msg,
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Tx hash: %s\n", result.TxHash)
```

After executing this code, you will see output like this:

```
Tx hash: 8C694A92A2208DB8CE733D54C22A3C7F945D54867B9078D08686DC7DBF0F44DC
```

You may copy transaction hash and paste it in the search box of our block explorer (https://explorer.devnet-1.coreum.dev)
to confirm the transaction execution and check its properties.

## Querying the balance

Now you may query the balance of your account:

```go
	bankClient := banktypes.NewQueryClient(clientCtx)
	balances, err := bankClient.AllBalances(ctx, &banktypes.QueryAllBalancesRequest{
		Address: senderInfo.GetAddress().String(),
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Balances: %s\n", balances.Balances)
```

After executing it should produce output like:

```
Balances: 9999982605ducore
```

## Complete code

Here is the complete code listing with all the features implemented above:

```go
package main

import (
	"context"
	"fmt"

	cosmosclient "github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keyring"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/bank"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"

	"github.com/CoreumFoundation/coreum/pkg/client"
	"github.com/CoreumFoundation/coreum/pkg/config/constant"
)

func main() {
	const (
		walletMnemonic = "" // put mnemonic here

		addressPrefix    = "devcore"
		chainID          = "coreum-devnet-1"
		recipientAddress = "devcore1ckuncyw0hftdq5qfjs6ee2v6z73sq0urd390cd"
		nodeAddress      = "https://s-0.devnet-1.coreum.dev:443"
	)

	// Configure Cosmos SDK
	config := sdk.GetConfig()
	config.SetBech32PrefixForAccount(addressPrefix, addressPrefix+"pub")
	config.SetCoinType(constant.CoinType)
	config.Seal()

	// List required modules
	modules := module.NewBasicManager(
		auth.AppModuleBasic{},
		bank.AppModuleBasic{},
	)

	// Configure client context and tx factory
	rpcClient, err := cosmosclient.NewClientFromNode(nodeAddress)
	if err != nil {
		panic(err)
	}

	clientCtx := client.NewContext(client.DefaultContextConfig(), modules).
		WithChainID(chainID).
		WithClient(rpcClient).
		WithKeyring(keyring.NewInMemory()).
		WithBroadcastMode(flags.BroadcastBlock)

	txFactory := client.Factory{}.
		WithKeybase(clientCtx.Keyring()).
		WithChainID(clientCtx.ChainID()).
		WithTxConfig(clientCtx.TxConfig()).
		WithSimulateAndExecute(true)

	// Generate private key and add it to the keystore
	senderInfo, err := clientCtx.Keyring().NewAccount(
		"key-name",
		walletMnemonic,
		"",
		sdk.GetConfig().GetFullBIP44Path(),
		hd.Secp256k1,
	)
	if err != nil {
		panic(err)
	}

	// Broadcast transaction transferring funds
	msg := &banktypes.MsgSend{
		FromAddress: senderInfo.GetAddress().String(),
		ToAddress:   recipientAddress,
		Amount:      sdk.NewCoins(sdk.NewInt64Coin("ducore", 10)),
	}

	ctx := context.Background()
	result, err := client.BroadcastTx(
		ctx,
		clientCtx.WithFromAddress(senderInfo.GetAddress()),
		txFactory,
		msg,
	)
	if err != nil {
		panic(err)
	}
	fmt.Printf("Tx hash: %s\n", result.TxHash)

	// Query balances
	bankClient := banktypes.NewQueryClient(clientCtx)
	balances, err := bankClient.AllBalances(ctx, &banktypes.QueryAllBalancesRequest{
		Address: senderInfo.GetAddress().String(),
	})
	if err != nil {
		panic(err)
	}
	fmt.Printf("Balances: %s\n", balances.Balances)
}
```
